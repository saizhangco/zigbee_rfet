###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         10/Mar/2018  23:30:38 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\Source\SampleApp.c   #
#    Command line       =  -f E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\P #
#                          rojects\zstack\Samples\SampleApp\CC2530DB\..\..\.. #
#                          \Tools\CC2530DB\f8wRouter.cfg (-DCPU32MHZ          #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f                   #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\To #
#                          ols\CC2530DB\f8wConfig.cfg (-DZIGBEEPRO            #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFF1                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 E:\Coding\IAR\RFTag\ZigBeeD #
#                          ev\5_ZStack-2.5.1a\Projects\zstack\Samples\SampleA #
#                          pp\Source\SampleApp.c -D ZTOOL_P1 -D xMT_TASK -D   #
#                          xMT_SYS_FUNC -D xMT_ZDO_FUNC -D                    #
#                          LCD_SUPPORTED=DEBUG -lC E:\Coding\IAR\RFTag\ZigBee #
#                          Dev\5_ZStack-2.5.1a\Projects\zstack\Samples\Sample #
#                          App\CC2530DB\RouterEB\List\ -lA                    #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\RouterEB\Li #
#                          st\ --diag_suppress Pe001,Pa010 -o                 #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\RouterEB\Ob #
#                          j\ -e --no_code_motion --debug --core=plain        #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I E:\Coding\IAR\RFTag\ZigBee #
#                          Dev\5_ZStack-2.5.1a\Projects\zstack\Samples\Sample #
#                          App\CC2530DB\ -I E:\Coding\IAR\RFTag\ZigBeeDev\5_Z #
#                          Stack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2 #
#                          530DB\..\Source\ -I E:\Coding\IAR\RFTag\ZigBeeDev\ #
#                          5_ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\ #
#                          CC2530DB\..\..\..\ZMain\TI2530DB\ -I               #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\hal\include\ -I                     #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\hal\target\CC2530EB\ -I             #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\include\ -I                     #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\high_level\ -I                  #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\low_level\srf04\ -I             #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\low_level\srf04\single_chip\    #
#                          -I E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\P #
#                          rojects\zstack\Samples\SampleApp\CC2530DB\..\..\.. #
#                          \..\..\Components\mt\ -I                           #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\osal\include\ -I                    #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\services\saddr\ -I                  #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\services\sdata\ -I                  #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\af\ -I                        #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\nwk\ -I                       #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\sapi\ -I                      #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\sec\ -I                       #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\sys\ -I                       #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\zdo\ -I                       #
#                          E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\zmac\ -I E:\Coding\IAR\RFTag\ZigBee #
#                          Dev\5_ZStack-2.5.1a\Projects\zstack\Samples\Sample #
#                          App\CC2530DB\..\..\..\..\..\Components\zmac\f8w\   #
#                          -Ohz --require_prototypes                          #
#    List file          =  E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\RouterEB\Li #
#                          st\SampleApp.lst                                   #
#    Object file        =  E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\RouterEB\Ob #
#                          j\SampleApp.r51                                    #
#                                                                             #
#                                                                             #
###############################################################################

E:\Coding\IAR\RFTag\ZigBeeDev\5_ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\Source\SampleApp.c
      1          /**************************************************************************************************
      2            Filename:       SampleApp.c
      3            Revised:        $Date: 2009-03-18 15:56:27 -0700 (Wed, 18 Mar 2009) $
      4            Revision:       $Revision: 19453 $
      5          
      6            Description:    Sample Application (no Profile).
      7          
      8          
      9            Copyright 2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41            This application isn't intended to do anything useful, it is
     42            intended to be a simple example of an application's structure.
     43          
     44            This application sends it's messages either as broadcast or
     45            broadcast filtered group messages.  The other (more normal)
     46            message addressing is unicast.  Most of the other sample
     47            applications are written to support the unicast message model.
     48          
     49            Key control:
     50              SW1:  Sends a flash command to all devices in Group 1.
     51              SW2:  Adds/Removes (toggles) this device in and out
     52                    of Group 1.  This will enable and disable the
     53                    reception of the flash command.
     54          *********************************************************************/
     55          
     56          /*********************************************************************
     57           * INCLUDES
     58           */
     59          #include "OSAL.h"
     60          #include "ZGlobals.h"
     61          #include "AF.h"
     62          #include "aps_groups.h"
     63          #include "ZDApp.h"
     64          
     65          #include "SampleApp.h"
     66          #include "SampleAppHw.h"
     67          #include "SampleRF.h"
     68          #include "SampleUtils.h"
     69          
     70          #include "OnBoard.h"
     71          
     72          /* HAL */
     73          #include "hal_lcd.h"
     74          #include "hal_led.h"
     75          #include "hal_key.h"
     76          #include "MT_UART.h"
     77          #include "MT_APP.h"
     78          #include "MT.h"
     79          
     80          /*********************************************************************
     81           * MACROS
     82           */
     83          
     84          /*********************************************************************
     85           * CONSTANTS
     86           */
     87          
     88          /*********************************************************************
     89           * TYPEDEFS
     90           */
     91          
     92          /*********************************************************************
     93           * GLOBAL VARIABLES
     94           */
     95          
     96          // This list should be filled with Application specific Cluster IDs.
     97          const cId_t SampleApp_ClusterList[SAMPLEAPP_MAX_CLUSTERS] =
     98          {
     99              SAMPLEAPP_PERIODIC_CLUSTERID,
    100              SAMPLEAPP_FLASH_CLUSTERID,
    101              SAMPLEAPP_P2P_CLUSTERID
    102          };
    103          
    104          const SimpleDescriptionFormat_t SampleApp_SimpleDesc =
    105          {
    106              SAMPLEAPP_ENDPOINT,              //  int Endpoint;
    107              SAMPLEAPP_PROFID,                //  uint16 AppProfId[2];
    108              SAMPLEAPP_DEVICEID,              //  uint16 AppDeviceId[2];
    109              SAMPLEAPP_DEVICE_VERSION,        //  int   AppDevVer:4;
    110              SAMPLEAPP_FLAGS,                 //  int   AppFlags:4;
    111              SAMPLEAPP_MAX_CLUSTERS,          //  uint8  AppNumInClusters;
    112              (cId_t *)SampleApp_ClusterList,  //  uint8 *pAppInClusterList;
    113              SAMPLEAPP_MAX_CLUSTERS,          //  uint8  AppNumInClusters;
    114              (cId_t *)SampleApp_ClusterList   //  uint8 *pAppInClusterList;
    115          };
    116          
    117          // This is the Endpoint/Interface description.  It is defined here, but
    118          // filled-in in SampleApp_Init().  Another way to go would be to fill
    119          // in the structure here and make it a "const" (in code space).  The
    120          // way it's defined in this sample app it is define in RAM.
    121          endPointDesc_t SampleApp_epDesc;
    122          
    123          /*********************************************************************
    124           * EXTERNAL VARIABLES
    125           */
    126          
    127          /*********************************************************************
    128           * EXTERNAL FUNCTIONS
    129           */
    130          
    131          /*********************************************************************
    132           * LOCAL VARIABLES
    133           */
    134          uint8 SampleApp_TaskID;   // Task ID for internal task/event processing
    135                                    // This variable will be received when
    136                                    // SampleApp_Init() is called.
    137          devStates_t SampleApp_NwkState;
    138          
    139          uint8 SampleApp_TransID;  // This is the unique message ID (counter)
    140          
    141          afAddrType_t SampleApp_Periodic_DstAddr; //广播
    142          afAddrType_t SampleApp_Flash_DstAddr;    //组播
    143          afAddrType_t SampleApp_P2P_DstAddr;      //点播
    144          
    145          aps_Group_t SampleApp_Group;
    146          
    147          uint8 SampleAppPeriodicCounter = 0;
    148          uint8 SampleAppFlashCounter = 0;
    149          
    150          //应用层变量
    151          endDevMsg_t localEndDevMsg;
    152          appMsg_t    localAppMsg;
    153          uint8 SampleAppAckEvent = NOT_EXIST;
    154          
    155          
    156          /*********************************************************************
    157           * LOCAL FUNCTIONS
    158           */
    159          void SampleApp_HandleKeys( uint8 shift, uint8 keys );
    160          void SampleApp_MessageMSGCB( afIncomingMSGPacket_t *pckt );
    161          void SampleApp_SendPeriodicMessage( void );
    162          void SampleApp_SendFlashMessage( uint16 flashTime );
    163          void SampleApp_Send_P2P_Message(void);
    164          void SampleApp_GetShortAddrStr(uint8* addrCA);
    165          uint8 _SampleApp_CharToHex(uint8 ch);
    166          uint16 SampleApp_GetShortAddrUint16(uint8* addrCA);
    167          void SampleApp_Uint16ToStr(uint16 guid, uint8* guid_str);
    168          
    169          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_COORDINATOR )	//协调器
    170          //串口处理函数
    171          void SampleApp_ProcessUartData(mtOSALSerialData_t *MSGpkt); 
    172          //通过无线发送数据到终端设备
    173          void SampleApp_Send_C2E_Message( uint8* msg );              
    174          #endif //协调器
    175          
    176          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_ENDDEVICE )	//终端设备
    177          void SampleApp_GetGUIDStr(uint8* str);
    178          // 终端设备给协调器回复
    179          void SampleApp_Send_E2C_Ack( uint8* value, uint8 length );
    180          // 终端设备主动发送PushButton事件
    181          void SampleApp_Send_E2C_PushBtn_Evt( uint8 evt );
    182          #endif  //终端设备
    183          
    184          /*********************************************************************
    185           * NETWORK LAYER CALLBACKS
    186           */
    187          
    188          /*********************************************************************
    189           * PUBLIC FUNCTIONS
    190           */
    191          
    192          /*********************************************************************
    193           * @fn      SampleApp_Init
    194           *
    195           * @brief   Initialization function for the Generic App Task.
    196           *          This is called during initialization and should contain
    197           *          any application specific initialization (ie. hardware
    198           *          initialization/setup, table initialization, power up
    199           *          notificaiton ... ).
    200           *
    201           * @param   task_id - the ID assigned by OSAL.  This ID should be
    202           *                    used to send messages and set timers.
    203           *
    204           * @return  none
    205           */
    206          void SampleApp_Init( uint8 task_id )
    207          { 
    208              uint16 _guid = GUID;
    209              uint8  _guid_str[4];
    210              SampleApp_TaskID = task_id;
    211              SampleApp_NwkState = DEV_INIT;
    212              SampleApp_TransID = 0;
    213            
    214              MT_UartInit();                  //串口初始化
    215              MT_UartRegisterTaskID(task_id); //注册串口任务
    216            
    217              // Device hardware initialization can be added here or in main() (Zmain.c).
    218              // If the hardware is application specific - add it here.
    219              // If the hardware is other parts of the device add it in main().
    220          
    221          #if defined ( BUILD_ALL_DEVICES )
    222              // The "Demo" target is setup to have BUILD_ALL_DEVICES and HOLD_AUTO_START
    223              // We are looking at a jumper (defined in SampleAppHw.c) to be jumpered
    224              // together - if they are - we will start up a coordinator. Otherwise,
    225              // the device will start as a router.
    226              if ( readCoordinatorJumper() )
    227                  zgDeviceLogicalType = ZG_DEVICETYPE_COORDINATOR;
    228              else
    229                  zgDeviceLogicalType = ZG_DEVICETYPE_ROUTER;
    230          #endif // BUILD_ALL_DEVICES
    231          
    232          #if defined ( HOLD_AUTO_START )
    233              // HOLD_AUTO_START is a compile option that will surpress ZDApp
    234              //  from starting the device and wait for the application to
    235              //  start the device.
    236              ZDOInitDevice(0);
    237          #endif
    238          
    239              // Setup for the periodic message's destination address
    240              // Broadcast to everyone
    241              SampleApp_Periodic_DstAddr.addrMode = (afAddrMode_t)AddrBroadcast;//广播
    242              SampleApp_Periodic_DstAddr.endPoint = SAMPLEAPP_ENDPOINT;
    243              SampleApp_Periodic_DstAddr.addr.shortAddr = 0xFFFF;
    244          
    245              // Setup for the flash command's destination address - Group 1
    246              SampleApp_Flash_DstAddr.addrMode = (afAddrMode_t)afAddrGroup;//组播
    247              SampleApp_Flash_DstAddr.endPoint = SAMPLEAPP_ENDPOINT;
    248              SampleApp_Flash_DstAddr.addr.shortAddr = SAMPLEAPP_FLASH_GROUP;
    249            
    250              SampleApp_P2P_DstAddr.addrMode = (afAddrMode_t)Addr16Bit; //点播 
    251              SampleApp_P2P_DstAddr.endPoint = SAMPLEAPP_ENDPOINT; 
    252          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_COORDINATOR )	//如果是协调器
    253              SampleApp_P2P_DstAddr.addr.shortAddr = 0x0001;            //发给终端设备
    254          #else
    255              SampleApp_P2P_DstAddr.addr.shortAddr = 0x0000;            //发给协调器
    256          #endif
    257          
    258              // Fill out the endpoint description.
    259              SampleApp_epDesc.endPoint = SAMPLEAPP_ENDPOINT;
    260              SampleApp_epDesc.task_id = &SampleApp_TaskID;
    261              SampleApp_epDesc.simpleDesc
    262                      = (SimpleDescriptionFormat_t *)&SampleApp_SimpleDesc;
    263              SampleApp_epDesc.latencyReq = noLatencyReqs;
    264          
    265              // Register the endpoint description with the AF
    266              afRegister( &SampleApp_epDesc );
    267          
    268              // Register for all key events - This app will handle all key events
    269              RegisterForKeys( SampleApp_TaskID );
    270          
    271              // By default, all devices start out in Group 1
    272              SampleApp_Group.ID = 0x0001;
    273              osal_memcpy( SampleApp_Group.name, "Group 1", 7  );
    274              aps_AddGroup( SAMPLEAPP_ENDPOINT, &SampleApp_Group );
    275          
    276          #if defined ( LCD_SUPPORTED )
    277              HalLcdWriteString( "SampleApp", HAL_LCD_LINE_1 );
    278              SampleApp_Uint16ToStr(_guid,_guid_str);
    279              HalLcdWriteString( (char*)_guid_str, HAL_LCD_LINE_4 );
    280          #endif
    281          }
    282          
    283          /*********************************************************************
    284           * @fn      SampleApp_ProcessEvent
    285           *
    286           * @brief   Generic Application Task event processor.  This function
    287           *          is called to process all events for the task.  Events
    288           *          include timers, messages and any other user defined events.
    289           *
    290           * @param   task_id  - The OSAL assigned task ID.
    291           * @param   events - events to process.  This is a bit map and can
    292           *                   contain more than one event.
    293           *
    294           * @return  none
    295           */
    296          uint16 SampleApp_ProcessEvent( uint8 task_id, uint16 events )
    297          {
    298              afIncomingMSGPacket_t *MSGpkt;
    299              (void)task_id;  // Intentionally unreferenced parameter
    300          
    301              if ( events & SYS_EVENT_MSG )
    302              {
    303                  MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( SampleApp_TaskID );
    304                  while ( MSGpkt )
    305                  {
    306                      switch ( MSGpkt->hdr.event )
    307                      {
    308                          // Received when a key is pressed
    309                          case KEY_CHANGE:
    310                              SampleApp_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
    311                              break;
    312          
    313                          // Received when a messages is received (OTA) for this endpoint
    314                          case AF_INCOMING_MSG_CMD:
    315                              SampleApp_MessageMSGCB( MSGpkt );
    316                              break;
    317          
    318                          // Received whenever the device changes state in the network
    319                          case ZDO_STATE_CHANGE:
    320                              SampleApp_NwkState = (devStates_t)(MSGpkt->hdr.status);
    321                              if ( //(SampleApp_NwkState == DEV_ZB_COORD) ||
    322                                   //(SampleApp_NwkState == DEV_ROUTER)   || 
    323          			 (SampleApp_NwkState == DEV_END_DEVICE) )
    324                              {
    325                                  // Start sending the periodic message in a regular interval.
    326                                  osal_start_timerEx( SampleApp_TaskID,
    327                                        SAMPLEAPP_SEND_PERIODIC_MSG_EVT,
    328                                        SAMPLEAPP_SEND_PERIODIC_MSG_TIMEOUT );
    329                              }
    330                              else
    331                              {
    332                                  // Device is no longer in the network
    333                              }
    334                              break;
    335          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_COORDINATOR )	//协调器
    336                          case CMD_SERIAL_MSG:
    337          #ifdef ZS_DEBUG_UART
    338                              HalUARTWrite(0,"CMD_SERIAL_MSG\n", sizeof("CMD_SERIAL_MSG\n"));
    339          #endif
    340                              SampleApp_ProcessUartData((mtOSALSerialData_t *)MSGpkt);
    341                              break;
    342          #endif
    343                          default:
    344                              break;
    345                      }
    346          
    347                      // Release the memory
    348                      osal_msg_deallocate( (uint8 *)MSGpkt );
    349          
    350                      // Next - if one is available
    351                      MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( SampleApp_TaskID );
    352                  }
    353          
    354                  // return unprocessed events
    355                  return (events ^ SYS_EVENT_MSG);
    356              }
    357          
    358              // Send a message out - This event is generated by a timer
    359              //  (setup in SampleApp_Init()).
    360              if ( events & SAMPLEAPP_SEND_PERIODIC_MSG_EVT )
    361              {
    362                  // Send the periodic message
    363                  //SampleApp_SendPeriodicMessage();
    364                  SampleApp_Send_P2P_Message();
    365          
    366                  // Setup to send message again in normal period (+ a little jitter)
    367                  osal_start_timerEx( SampleApp_TaskID, SAMPLEAPP_SEND_PERIODIC_MSG_EVT,
    368                      (SAMPLEAPP_SEND_PERIODIC_MSG_TIMEOUT + (osal_rand() & 0x00FF)) );
    369          
    370                  // return unprocessed events
    371                  return (events ^ SAMPLEAPP_SEND_PERIODIC_MSG_EVT);
    372              }
    373              if( events & SAMPLEAPP_SEND_RESPONSE_MSG_EVT )
    374              {
    375                  SampleApp_Send_P2P_Message();
    376          	return (events ^ SAMPLEAPP_SEND_RESPONSE_MSG_EVT);
    377              }
    378          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_ENDDEVICE )	//终端设备
    379              //触发按键确认事件
    380              if( events & SAMPLEAPP_KEY_ACK_EVT )
    381              {
    382          #if 1 //调试-确认事件触发
    383                  HalUARTWrite(0x00, "SAMPLEAPP_KEY_ACK_EVT\n", 22);       
    384          #endif
    385                  //1 判断是否存在确认事件
    386                  if( SampleAppAckEvent != NOT_EXIST )
    387                  {
    388                      //2 根据localEndDevMsg中的内容发送确认事件
    389                      if( 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"TKME",4) )
    390                      {
    391                          // Take Medicines
    392                          SampleApp_Send_E2C_PushBtn_Evt(SampleAppAckEvent);
    393                      }
    394                      else if( 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"ADME",4) )
    395                      {
    396                          // Add Medicines
    397                          SampleApp_Send_E2C_PushBtn_Evt(SampleAppAckEvent);
    398                      }
    399                  }
    400                  return ( events ^ SAMPLEAPP_KEY_ACK_EVT );
    401              }
    402              //触发按键查询事件
    403              if( events & SAMPLEAPP_KEY_QUERY_EVT )
    404              {
    405          #if 1 //查询事件触发调试
    406                  HalUARTWrite(0x00, "SAMPLEAPP_KEY_QUERY_EVT\n", 24);       
    407          #endif
    408                  //1 判断是否存在确认事件
    409                  if( SampleAppAckEvent == NOT_EXIST )
    410                  {
    411                      // Query Medicines
    412                      SampleApp_Send_E2C_PushBtn_Evt(QUERY_MEDIC_EVT);
    413                  }
    414                  return ( events ^ SAMPLEAPP_KEY_QUERY_EVT );
    415              }
    416          #endif  //终端设备
    417              // Discard unknown events
    418              return 0;
    419          }
    420          
    421          /*********************************************************************
    422           * Event Generation Functions
    423           */
    424          /*********************************************************************
    425           * @fn      SampleApp_HandleKeys
    426           *
    427           * @brief   Handles all key events for this device.
    428           *
    429           * @param   shift - true if in shift/alt.
    430           * @param   keys - bit field for key events. Valid entries:
    431           *                 HAL_KEY_SW_2
    432           *                 HAL_KEY_SW_1
    433           *
    434           * @return  none
    435           */
    436          void SampleApp_HandleKeys( uint8 shift, uint8 keys )
    437          {
    438          #if 0
    439              uint8 str4lcd[6];
    440          #endif
    441              (void)shift;  // Intentionally unreferenced parameter
    442            
    443              if ( keys & HAL_KEY_SW_1 )
    444              {
    445                  /* This key sends the Flash Command is sent to Group 1.
    446                   * This device will not receive the Flash Command from this
    447                   * device (even if it belongs to group 1).
    448                   */
    449                  //SampleApp_SendFlashMessage( SAMPLEAPP_FLASH_DURATION );
    450                  //替换成我的程序，进行按键处理
    451                  HalUARTWrite(0x00, "HAL_KEY_SW_1\n", 13);       //按键1触发调试
    452          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_COORDINATOR )	//协调器
    453                  
    454          #elif ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_ENDDEVICE )	//终端设备                                                   //终端设备
    455          	//发送按键 确认动作 事件
    456          	osal_set_event( SampleApp_TaskID, SAMPLEAPP_KEY_ACK_EVT );
    457          #endif
    458              }
    459          
    460              if ( keys & HAL_KEY_SW_2 )
    461              {
    462                  /* The Flashr Command is sent to Group 1.
    463                   * This key toggles this device in and out of group 1.
    464                   * If this device doesn't belong to group 1, this application
    465                   * will not receive the Flash command sent to group 1.
    466                   */
    467                  /*
    468                  aps_Group_t *grp;
    469                  grp = aps_FindGroup( SAMPLEAPP_ENDPOINT, SAMPLEAPP_FLASH_GROUP );
    470                  if ( grp )
    471                  {
    472                      // Remove from the group
    473                      aps_RemoveGroup( SAMPLEAPP_ENDPOINT, SAMPLEAPP_FLASH_GROUP );
    474                  }
    475                  else
    476                  {
    477                      // Add to the flash group
    478                      aps_AddGroup( SAMPLEAPP_ENDPOINT, &SampleApp_Group );
    479                  }
    480                  */
    481                  HalUARTWrite(0x00, "HAL_KEY_SW_2\n", 13);       //按键2串口调试
    482              }
    483              if ( keys & HAL_KEY_SW_6 )
    484              {
    485                  HalUARTWrite(0x00, "HAL_KEY_SW_6\n", 13);       //按键6串口调试
    486          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_ENDDEVICE )	//终端设备
    487          	    //设置按键 查询动作 事件
    488          	    osal_set_event( SampleApp_TaskID, SAMPLEAPP_KEY_QUERY_EVT );
    489          #endif
    490          //==================================================================
    491          #if 0
    492                  //获取设备短地址，并通过发送到串口
    493                  SampleApp_GetShortAddrStr(str4lcd);
    494                  HalUARTWrite(0x00, str4lcd, 4);
    495                  HalUARTWrite(0x00, "\n", 1);
    496                  str4lcd[4] = ':';
    497          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_COORDINATOR )	//协调器
    498                  str4lcd[5] = 'C';
    499          #elif ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_ROUTER )	//路由器
    500                  str4lcd[5] = 'R';
    501          #elif ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_ENDDEVICE )	//终端设备
    502                  str4lcd[5] = 'E';
    503          	    //设置按键 查询动作 事件
    504          	    osal_set_event( SampleApp_TaskID, SAMPLEAPP_KEY_QUERY_EVT );
    505          #else 
    506                  str4lcd[5] = 'U'; 
    507          #endif
    508          	    //将短地址在LCD上显示
    509                  HalLcdWriteString( (char*)str4lcd, HAL_LCD_LINE_3 );
    510          #endif // if 0
    511          //===================================================================
    512              }
    513          }
    514          
    515          /*********************************************************************
    516           * LOCAL FUNCTIONS
    517           */
    518          
    519          /*********************************************************************
    520           * @fn      SampleApp_MessageMSGCB
    521           *
    522           * @brief   Data message processor callback.  This function processes
    523           *          any incoming data - probably from other devices.  So, based
    524           *          on cluster ID, perform the intended action.
    525           *
    526           * @param   none
    527           *
    528           * @return  none
    529           */
    530          void SampleApp_MessageMSGCB( afIncomingMSGPacket_t *pkt )
    531          {
    532              uint16 flashTime;
    533          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_COORDINATOR )	//协调器
    534              //uint16 _shortAddr = 0x01;/* 保存短地址 */
    535              uint8 i = 0x00;  //用来计数的
    536              uint8 format = 0x00;
    537              uint8 tmp[4] = {0};
    538              uint8 *value;
    539          #else                                                   //终端设备
    540              uint8 *lcdData;
                            ^
Warning[Pe177]: variable "lcdData" was declared but never referenced
    541              uint8 i = 0x00;
                           ^
Warning[Pe177]: variable "i" was declared but never referenced
    542              uint16 tmp = 0x00;
                            ^
Warning[Pe177]: variable "tmp" was declared but never referenced
    543              uint16 num = 0x00;
                            ^
Warning[Pe177]: variable "num" was declared but never referenced
    544              uint8  format = 0x00;
                            ^
Warning[Pe177]: variable "format" was declared but never referenced
    545          #endif
    546          
    547              switch ( pkt->clusterId )
    548              {
    549                  case SAMPLEAPP_P2P_CLUSTERID:
    550          
    551          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_COORDINATOR )	//协调器
    552          #if 0 //是否启用串口调试
    553                      HalUARTWrite(0, "Coord:[", 7);       //提示接收到数据
    554                      HalUARTWrite(0, pkt->cmd.Data, pkt->cmd.DataLength); //串口输出接收到的数据
    555                      HalUARTWrite(0, "]\n", 2);         // 回车换行
    556          #endif //是否启用串口调试
    557          #elif ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_ENDDEVICE )	//终端设备
    558          	    HalUARTWrite(0,   "End:[", 5);       //提示接收到数据
    559                      HalUARTWrite(0, pkt->cmd.Data, pkt->cmd.DataLength); //串口输出接收到的数据
    560                      HalUARTWrite(0, "]\n", 2);         // 回车换行
    561          #endif
    562                              
    563          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_COORDINATOR )	//协调器
    564          	    /*
    565                      //返回数据到终端设备
    566                      _shortAddr = SampleApp_GetShortAddrUint16(pkt->cmd.Data);
    567                      SampleApp_P2P_DstAddr.addr.shortAddr = _shortAddr;            //发给终端设备
    568                      //SampleApp_Send_P2P_Message();
    569                      osal_set_event( SampleApp_TaskID, SAMPLEAPP_SEND_RESPONSE_MSG_EVT );
    570                      */
    571                      /*
    572                       * 0~3 id
    573                       * 4~7 command
    574                       * 8   length - n
    575                       * 9~n+9 value
    576                       */
    577                      //1.将接收到的数据保存在全局变量中。收到数据的长度必须大于9，否则丢弃。
    578                      if( pkt->cmd.DataLength >= 9 )
    579                      {
    580                          // id
    581                          for( i=0; i<4; i++ )
    582                          {
    583                              localEndDevMsg.guid[i] = pkt->cmd.Data[i];
    584                          }
    585                          // command
    586                          for( i=0; i<4; i++ )
    587                          {
    588                              localEndDevMsg.command[i] = pkt->cmd.Data[i+4];
    589                          }
    590                          localEndDevMsg.length = pkt->cmd.Data[8];
    591                          if( localEndDevMsg.length > 0 )
    592                          {
    593                              value = (uint8*)osal_msg_allocate(localEndDevMsg.length);
    594                              if( 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"PING",4) )
    595                              {
    596                                  if( pkt->cmd.DataLength >= 13)
    597                                  {
    598          #if 0
    599                                      for( i=0; i<4; i++ )
    600                                      {
    601                                          localEndDevMsg.value.short_addr[i] = pkt->cmd.Data[i+9];
    602                                      }
    603          #endif
    604                                      for( i=0; i<localEndDevMsg.length; i++ )
    605                                      {
    606                                          value[i] = pkt->cmd.Data[i+9];
    607                                      }
    608                                  }
    609                                  else
    610                                  {
    611                                      //格式错误
    612                                      format = 0x01;
    613                                  }
    614                              }
    615                              else if( 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"TKME",4) ||
    616                                       0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"ADME",4)
    617                                      )
    618                              {
    619                                  if( pkt->cmd.DataLength >= (9+localEndDevMsg.length) )
    620                                  {
    621                                      for( i=0; i<localEndDevMsg.length; i++ )
    622                                      {
    623                                          value[i] = pkt->cmd.Data[i+9];
    624                                      }
    625                                  }
    626                                  else
    627                                  {
    628                                      //格式错误
    629                                      format = 0x01;
    630                                  }
    631                              }
    632                              else  //扩展
    633                              {
    634                                  if( pkt->cmd.DataLength >= (9+localEndDevMsg.length) )
    635                                  {
    636                                      for( i=0; i<localEndDevMsg.length; i++ )
    637                                      {
    638                                          value[i] = pkt->cmd.Data[i+9];
    639                                      }
    640                                  }
    641                                  else
    642                                  {
    643                                      //格式错误
    644                                      format = 0x01;
    645                                  }
    646                              }
    647                          }
    648                      }
    649                      else
    650                      {
    651                          //格式错误
    652                          format = 0x02;
    653                      }
    654                      //2 通过串口发送到上位机
    655                      if( format == 0x01 )
    656                      { 
    657                          //格式错误
    658                          
    659                      }
    660                      else if( format == 0x02 )
    661                      {
    662                          //格式错误
    663                      }
    664                      else if( format == 0x00 )
    665                      {
    666                          /*
    667                           * sof
    668                           * length
    669                           * guid
    670                           * command
    671                           * value
    672                           */
    673                          HalUARTWrite(0x00, "#", 1);
    674                          tmp[0] = localEndDevMsg.length;
    675                          HalUARTWrite(0x00, tmp, 1);
    676                          HalUARTWrite(0x00, localEndDevMsg.guid, 4);
    677                          HalUARTWrite(0x00, localEndDevMsg.command, 4);
    678                          //HalUARTWrite(0x00, localEndDevMsg.value.short_addr, 4);
    679                          if( localEndDevMsg.length > 0 )
    680                          {
    681                              tmp[0] = localEndDevMsg.length;
    682                              HalUARTWrite(0x00, value, localEndDevMsg.length);
    683                              osal_msg_deallocate(value);
    684                          }
    685          #if 1   //调试时，控制台换行
    686                          HalUARTWrite(0x00, "\n", 1);
    687          #endif
    688                      }
    689          #elif ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_ENDDEVICE )	//终端设备
    690                      /*
    691                       * 0~3 id
    692                       * 4~7 command
    693                       * 8   length - n
    694                       * 9~n+9 value
    695                       */
    696                      //1.将接收到的数据保存在全局变量中。收到数据的长度必须大于9，否则丢弃。
    697                      if( pkt->cmd.DataLength >= 9 )
    698                      {
    699                          // id
    700                          for( i=0; i<4; i++ )
    701                          {
    702                              localEndDevMsg.guid[i] = pkt->cmd.Data[i];
    703                          }
    704                          // command
    705                          for( i=0; i<4; i++ )
    706                          {
    707                              localEndDevMsg.command[i] = pkt->cmd.Data[i+4];
    708                          }
    709                          // length
    710                          localEndDevMsg.length = pkt->cmd.Data[8];
    711                          // value
    712                          if( localEndDevMsg.length > 0 )
    713                          {
    714                              if( 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"TKME",4)   // TKME
    715                                 || 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"ADME",4) // ADME
    716                                 || 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"LTME",4) // LTME
    717                                   )
    718                              {
    719                                  if( pkt->cmd.DataLength >= (localEndDevMsg.length+9))
    720                                  {
    721                                      localEndDevMsg.value.number = SampleUtil_GetValueFromU8Array(&pkt->cmd.Data[9], localEndDevMsg.length);
    722                                  }
    723                                  else
    724                                  {
    725                                      //格式错误2，value的数据长度与length不匹配
    726                                      format = 0x02;
    727                                  }
    728                              }
    729                          }
    730                      }
    731                      else
    732                      {
    733                          //格式错误1，数据长度小于9个字节
    734                          format = 0x01;
    735                      }
    736                      //2 通过串口发送到上位机
    737                      if( format == 0x01 )
    738                      { 
    739                          //格式错误1，数据长度小于9个字节
    740                          //无线回复 "FEEG" "Generic Error"
    741                          SampleApp_Send_E2C_Ack("FEEG",4);
    742                      }
    743                      else if( format == 0x02 )
    744                      {
    745                          //格式错误2，value的数据长度与length不匹配
    746                          //无线回复 "FEEV" value数据长度不匹配
    747                          SampleApp_Send_E2C_Ack("FEEV",4);
    748                      }
    749                      else if( format == 0x00 )
    750                      {
    751                          /*
    752                           * sof
    753                           * length
    754                           * guid
    755                           * command
    756                           * value
    757                           */
    758          #if 1
    759                          //1 验证ID格式，错误无线回复 "FEEI"，并break
    760                          if( 0x00 != SampleUtil_ValidateGuidFormat(localEndDevMsg.guid) )
    761                          {
    762                              //无线回复 "FEEI"
    763                              SampleApp_Send_E2C_Ack("FEEI",4); 
    764                              break;
    765                          }
    766                          //2 验证CMD命令格式，错误无线回复 "FEEC"，并break
    767                          if( ! ( 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"TKME",4)   // TKME
    768                                 || 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"ADME",4) // ADME
    769                                 || 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"AKTK",4) // AKTK
    770                                 || 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"AKAD",4) // AKAD
    771                                 || 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"LTME",4) // LTME
    772                                ) )
    773                          {
    774                              //无线回复 "FEEC"
    775                              SampleApp_Send_E2C_Ack("FEEC",4); 
    776                              break;
    777                          }
    778                          //3 验证ID和当前设备FW写入的ID是否匹配，不匹配无线回复 "IDNM"，并break
    779                          if( GUID != SampleUtil_GetShortAddrFromU8Array(localEndDevMsg.guid) )
    780                          {
    781                              //无线回复 "IDNM"
    782                              SampleApp_Send_E2C_Ack("IDNM",4); 
    783                              break;
    784                          }
    785          
    786                          //4.1 在LCD上显示，并点亮指示灯，无线回复 "OK"
    787                          if( 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"TKME",4)   // TKME
    788                                 || 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"ADME",4) // ADME
    789                                 || 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"LTME",4) // LTME
    790                            )
    791                          {
    792                              lcdData = (uint8*)osal_msg_allocate(7+localEndDevMsg.length);
    793                              for( i=0;i<4;i++ )
    794                              {
    795                                  lcdData[i] = localEndDevMsg.command[i];
    796                              }
    797                              lcdData[4] = '[';
    798                              num = localEndDevMsg.value.number;
    799                              for( i=0;i<localEndDevMsg.length;i++ )
    800                              {
    801                                  tmp = num % 10;
    802                                  lcdData[localEndDevMsg.length+4-i] = tmp+'0';
    803                                  num /= 10;
    804                              }
    805                              lcdData[5+localEndDevMsg.length] = ']';
    806                              lcdData[6+localEndDevMsg.length] = '\0';
    807                              HalLcdWriteString( (char*)lcdData, HAL_LCD_LINE_3 );
    808                              osal_msg_deallocate((uint8*)lcdData);
    809                              //无线回复 "OK"
    810                              SampleApp_Send_E2C_Ack("OK",2);
    811                              
    812                              if( 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"TKME",4)   // TKME
    813                                )
    814                              {
    815                                  SampleAppAckEvent = TAKE_MEDIC_EVT;
    816                              }
    817                              else if( 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"ADME",4) // ADME
    818                                     )
    819                              {
    820                                  SampleAppAckEvent = ADD_MEDIC_EVT;
    821                              }
    822                          }
    823                          else if( 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"AKTK",4) // AKTK
    824                                 )
    825                          {
    826                              SampleAppAckEvent = NOT_EXIST;
    827                          }
    828                          else if( 0x00 == SampleUtil_CompareUint8Array(localEndDevMsg.command,"AKAD",4) // AKAD
    829                                 )
    830                          {
    831                              SampleAppAckEvent = NOT_EXIST;
    832                          }
    833          #endif
    834          #if 0
    835                          HalLcdWriteStringValue("TAKE:",localEndDevMsg.value.number,10,HAL_LCD_LINE_3);
    836          #endif
    837                      }
    838          #endif
    839                      break;    
    840                  case SAMPLEAPP_PERIODIC_CLUSTERID:
    841                      break;
    842          
    843                  case SAMPLEAPP_FLASH_CLUSTERID:
    844                      flashTime = BUILD_UINT16(pkt->cmd.Data[1], pkt->cmd.Data[2] );
    845                      HalLedBlink( HAL_LED_4, 4, 50, (flashTime / 4) );
    846                      break;
    847              }
    848          }
    849          
    850          /*********************************************************************
    851           * @fn      SampleApp_SendPeriodicMessage
    852           *
    853           * @brief   Send the periodic message.
    854           *
    855           * @param   none
    856           *
    857           * @return  none
    858           */
    859          void SampleApp_SendPeriodicMessage( void )
    860          {
    861              if ( AF_DataRequest( &SampleApp_Periodic_DstAddr, &SampleApp_epDesc,
    862                                   SAMPLEAPP_PERIODIC_CLUSTERID,
    863                                   1,
    864                                   (uint8*)&SampleAppPeriodicCounter,
    865                                   &SampleApp_TransID,
    866                                   AF_DISCV_ROUTE,
    867                                   AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
    868              {
    869              }
    870              else
    871              {
    872                  // Error occurred in request to send.
    873              }
    874          }
    875          
    876          /*********************************************************************
    877           * @fn      SampleApp_SendFlashMessage
    878           *
    879           * @brief   Send the flash message to group 1.
    880           *
    881           * @param   flashTime - in milliseconds
    882           *
    883           * @return  none
    884           */
    885          void SampleApp_SendFlashMessage( uint16 flashTime )
    886          {
    887              uint8 buffer[3];
    888              buffer[0] = (uint8)(SampleAppFlashCounter++);
    889              buffer[1] = LO_UINT16( flashTime );
    890              buffer[2] = HI_UINT16( flashTime );
    891          
    892              if ( AF_DataRequest( &SampleApp_Flash_DstAddr, &SampleApp_epDesc,
    893                                   SAMPLEAPP_FLASH_CLUSTERID,
    894                                   3,
    895                                   buffer,
    896                                   &SampleApp_TransID,
    897                                   AF_DISCV_ROUTE,
    898                                   AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
    899              {
    900              }
    901              else
    902              {
    903                  // Error occurred in request to send.
    904              }
    905          }
    906          
    907          /*********************************************************************
    908           * @fn      SampleApp_Send_P2P_Message
    909           *
    910           * @brief   point to point.
    911           *          协调器或终端设备通过RF传输数据
    912           *
    913           * @param   none
    914           *
    915           * @return  none
    916           */
    917          void SampleApp_Send_P2P_Message( void )
    918          {
    919              uint16 length = 0x00;
    920          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_COORDINATOR )	//协调器
    921              uint8 data[11]="++++++++++";
    922              length = 11;
    923          #elif ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_ENDDEVICE )	//终端设备
    924              /*
    925               * 0~3 id
    926               * 4~7 command
    927               * 8   length - n
    928               * 9~n+9 value
    929               */
    930              uint8 i = 0;
    931              uint8 data[13]= {0};
    932              uint8 guid_str[4] = {0};
    933              uint8 short_addr[4] = {0};
    934              SampleApp_GetShortAddrStr(short_addr);
    935              SampleApp_GetGUIDStr(guid_str);
    936              for( i=0; i<4; i++ )
    937              {
    938                  data[i] = guid_str[i];
    939              }
    940              data[4] = 'P';
    941              data[5] = 'I';
    942              data[6] = 'N';
    943              data[7] = 'G';
    944              data[8] = 0x04;
    945              for( i=0; i<4; i++ )
    946              {
    947                  data[i+9] = short_addr[i];
    948              }
    949              length = 13;
    950          #endif
    951            
    952              if ( AF_DataRequest( &SampleApp_P2P_DstAddr, &SampleApp_epDesc,
    953                                 SAMPLEAPP_P2P_CLUSTERID,
    954                                 length,
    955                                 data,
                                        ^
Error[Pe020]: identifier "data" is undefined
    956                                 &SampleApp_TransID,
    957                                 AF_DISCV_ROUTE,
    958                                 AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
    959              {
    960              }
    961              else
    962              {
    963                  // Error occurred in request to send.
    964              }
    965          }
    966          
    967          /*********************************************************************
    968           * @fn      SampleApp_Send_C2E_Message
    969           *
    970           * @brief   point to point.
    971           *          协调器或终端设备通过RF传输数据
    972           *
    973           * @param   none
    974           *
    975           * @return  none
    976           */
    977          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_COORDINATOR )	//协调器
    978          void SampleApp_Send_C2E_Message( uint8* msg )
    979          {
    980              uint16 length = msg[SRF_POS_LEN] + 9; // n+9
    981              uint16 _shortAddr = 0x00;
    982              uint8* data;
    983              uint8 i = 0x00;
    984              
    985              //1 验证ID格式，错误串口回复 "FECI"，并return
    986              //2 验证CMD命令格式，错误串口回复 "FECC"，并return
    987              //3 验证ShortAddress格式，错误串口回复 "SADE"，并return
    988              
    989              data = (uint8*)osal_msg_allocate(length);
    990              
    991              _shortAddr = SampleUtil_GetShortAddrFromU8Array(&msg[SRF_POS_SA0]);
    992          #define C2E_DEBUG 0
    993          #if C2E_DEBUG    
    994              HalUARTWrite(0x00, &msg[SRF_POS_SA0], 4);
    995          #endif
    996              SampleApp_P2P_DstAddr.addr.shortAddr = _shortAddr;//0xDE8A;            //发给终端设备
    997              /*
    998               * 0~3 guid
    999               * 4~7 command
   1000               * 8   length
   1001               * 9~n+8 value
   1002               */
   1003              for( i=0;i<4;i++ )
   1004              {
   1005                  data[i] = msg[SRF_POS_ID0+i];
   1006              }
   1007              for( i=0;i<4;i++ )
   1008              {
   1009                  data[i+4] = msg[SRF_POS_CMD0+i];
   1010              }
   1011              data[8] = msg[SRF_POS_LEN];
   1012              for( i=0;i<data[8];i++ )
   1013              {
   1014                  data[9+i] = msg[SRF_POS_DAT0+i];
   1015              }
   1016          
   1017          #if C2E_DEBUG
   1018              HalUARTWrite(0x00, "A\n", 2);
   1019          #endif
   1020              if ( AF_DataRequest( &SampleApp_P2P_DstAddr, &SampleApp_epDesc,
   1021                                 SAMPLEAPP_P2P_CLUSTERID,
   1022                                 length,
   1023                                 data,
   1024                                 &SampleApp_TransID,
   1025                                 AF_DISCV_ROUTE,
   1026                                 AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   1027              {
   1028          #if C2E_DEBUG
   1029                  HalUARTWrite(0x00, "B\n", 2);
   1030          #endif
   1031              }
   1032              else
   1033              {
   1034                  // Error occurred in request to send.
   1035          #if C2E_DEBUG
   1036                  HalUARTWrite(0x00, "C\n", 2);
   1037          #endif
   1038              }
   1039              // Release the memory
   1040              osal_msg_deallocate( (uint8 *)data );
   1041          }
   1042          #endif  //协调器
   1043          
   1044          /*********************************************************************
   1045           * @fn      SampleApp_Send_E2C_Ack
   1046           *
   1047           * @brief   终端设备消息回复
   1048           *
   1049           * @param   none
   1050           *
   1051           * @return  none
   1052           */
   1053          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_ENDDEVICE )	//终端设备
   1054          void SampleApp_Send_E2C_Ack( uint8* value, uint8 length )
   1055          {
   1056              uint8  af_len = 9 + length;
   1057              uint8* data;
   1058              uint8 i = 0x00;
   1059              // localEndDevMsg
   1060              /*
   1061               * 0~3   guid
   1062               * 4~7   command
   1063               * 8     length - n
   1064               * 9~8+n value
   1065               */
   1066              
   1067              data = (uint8*)osal_msg_allocate(af_len);
   1068              SampleApp_P2P_DstAddr.addr.shortAddr = 0x0000;            //发给协调器
   1069              // guid
   1070              for( i=0;i<4;i++ )
   1071              {
   1072                  data[i] = localEndDevMsg.guid[i];
   1073              }
   1074              // command
   1075              for( i=0;i<4;i++ )
   1076              {
   1077                  data[i+4] = localEndDevMsg.command[i];
   1078              }
   1079              data[8] = length;
   1080              for( i=0;i<length;i++ )
   1081              {
   1082                  data[9+i] = value[i];
   1083              }
   1084            
   1085              HalUARTWrite(0x00, "E2C_Ack A\n", 10);
   1086              if ( AF_DataRequest( &SampleApp_P2P_DstAddr, &SampleApp_epDesc,
   1087                                 SAMPLEAPP_P2P_CLUSTERID,
   1088                                 af_len,
   1089                                 data,
   1090                                 &SampleApp_TransID,
   1091                                 AF_DISCV_ROUTE,
   1092                                 AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   1093              {
   1094                  HalUARTWrite(0x00, "E2C_Ack B\n", 10);
   1095              }
   1096              else
   1097              {
   1098                  // Error occurred in request to send.
   1099                  HalUARTWrite(0x00, "E2C_Ack C\n", 10);
   1100              }
   1101              // Release the memory
   1102              osal_msg_deallocate( (uint8 *)data );
   1103          }
   1104          #endif  //终端设备
   1105          
   1106          /*********************************************************************
   1107           * @fn      SampleApp_Send_E2C_Ack
   1108           *
   1109           * @brief   终端设备消息回复
   1110           *
   1111           * @param   none
   1112           *
   1113           * @return  none
   1114           */
   1115          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_ENDDEVICE )	//终端设备
   1116          void SampleApp_Send_E2C_PushBtn_Evt( uint8 evt )
   1117          {
   1118              uint8  af_len = 9;
   1119              uint8* data;
   1120              uint8 i = 0x00;
   1121              uint8 guid[4] = {0};
   1122              // localEndDevMsg
   1123              /*
   1124               * 0~3   guid
   1125               * 4~7   command
   1126               * 8     length - n
   1127               * 9~8+n value (目前为空)
   1128               */
   1129              
   1130              //1 申请数据内存空间
   1131              data = (uint8*)osal_msg_allocate(af_len);
   1132              //2 通过宏定义获取Guid
   1133              SampleApp_GetGUIDStr(guid);
   1134              //3 修改发送地址
   1135              SampleApp_P2P_DstAddr.addr.shortAddr = 0x0000;            //发给协调器
   1136              //4 填充发送数据
   1137              // guid
   1138              for( i=0;i<4;i++ )
   1139              {
   1140                  data[i] = guid[i];
   1141              }
   1142              // command
   1143              if( evt == TAKE_MEDIC_EVT )
   1144              {
   1145                  data[4] = 'A';
   1146                  data[5] = 'K';
   1147                  data[6] = 'T';
   1148                  data[7] = 'K';
   1149              }
   1150              else if( evt == ADD_MEDIC_EVT )
   1151              {
   1152                  data[4] = 'A';
   1153                  data[5] = 'K';
   1154                  data[6] = 'A';
   1155                  data[7] = 'D';
   1156              }
   1157              else if( evt == QUERY_MEDIC_EVT )
   1158              {
   1159                  data[4] = 'L';
   1160                  data[5] = 'T';
   1161                  data[6] = 'M';
   1162                  data[7] = 'E';
   1163              }
   1164              else
   1165              {
   1166                  osal_msg_deallocate( (uint8 *)data );
   1167                  return;
   1168              }
   1169              data[8] = 0x00;
   1170            
   1171              HalUARTWrite(0x00, "E2C_Evt A\n", 10);
   1172              if ( AF_DataRequest( &SampleApp_P2P_DstAddr, &SampleApp_epDesc,
   1173                                 SAMPLEAPP_P2P_CLUSTERID,
   1174                                 af_len,
   1175                                 data,
   1176                                 &SampleApp_TransID,
   1177                                 AF_DISCV_ROUTE,
   1178                                 AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   1179              {
   1180                  HalUARTWrite(0x00, "E2C_Evt B\n", 10);
   1181              }
   1182              else
   1183              {
   1184                  // Error occurred in request to send.
   1185                  HalUARTWrite(0x00, "E2C_Evt C\n", 10);
   1186              }
   1187              // Release the memory
   1188              osal_msg_deallocate( (uint8 *)data );
   1189          }
   1190          #endif  //终端设备
   1191          
   1192          /***********************************************************
   1193           * @fn      SampleApp_ProcessUartData
   1194           *
   1195           * @brief   将从串口接收到的数据，从串口发出
   1196           *
   1197           * @param   MSGpkt - 数据包内容
   1198           *
   1199           * @return  none
   1200           */
   1201          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_COORDINATOR )	//协调器
   1202          void SampleApp_ProcessUartData(mtOSALSerialData_t *MSGpkt)
   1203          {  
   1204              //为了正确地进行下面工作，用mtOSALSerialData_t类型来指向整个zigbee数据包(不是串口数据包)
   1205              uint8 *pMsg;
   1206              pMsg = MSGpkt->msg;
   1207              //定义一个指针，指向真正的串口接收数据存放位置，MSGptk里面还有一些别的Header噢。
   1208              switch ( MSGpkt->hdr.event )
   1209              {
   1210                case CMD_SERIAL_MSG://如果是串口消息，则进行下面的处理
   1211                  //HalLedSet( HAL_LED_RED, HAL_LED_MODE_FLASH );//用LED灯指示一下收到数据啦
   1212                  /*
   1213                  uint8 *pBuffer;
   1214                  uint8 datalength;
   1215                  uint8 i;    //定义几个变量，为从接收到的串口包里面提取数据以及写回串口做准备
   1216                  datalength = *pMsg++;
   1217                  //串口包中第一个字节是数据长度噢
   1218                  pBuffer = osal_mem_alloc(datalength);
   1219                  //分配一块内存准备把串口消息数据拿出来
   1220                  if(pBuffer != NULL)
   1221                  {
   1222                    for(i = 0;i < datalength; i++)
   1223                       *pBuffer++ = *pMsg++;
   1224                    //把消息中的串口数据按照datalength数量挨个捞出来放血(放血啥意思？把池子里面那东西捞出来放血，明白不？
   1225                    //HalUARTWrite(0,pBuffer,datalength);    //捞出来放血的串口数据再写回串口，也就是送到串口助手显示
   1226                    osal_mem_free(pBuffer); //动态申请的内存记得用完了free一下噢
   1227                  }
   1228                  */
   1229          #ifdef ZS_DEBUG_UART
   1230                  HalUARTWrite(0x00,"<" ,1);    /* 调试使用 */
   1231                  HalUARTWrite(0x00,&pMsg[SRF_POS_ID0] ,pMsg[MT_RPC_POS_LEN]+12);  /* 调试使用 */
   1232                  HalUARTWrite(0x00,">\n" ,2);  /* 调试使用 */
   1233          #endif
   1234                  SampleApp_Send_C2E_Message(&pMsg[MT_RPC_POS_LEN]);
   1235                  break;
   1236                default:
   1237                  break;
   1238              }
   1239          }
   1240          #endif //协调器
   1241          /*********************************************************************
   1242           * @fn      SampleApp_Uint16ToStr
   1243           *
   1244           * @brief   将16位数据转换成字符串
   1245           *
   1246           * @param   addrCA
   1247           *
   1248           * @return  none
   1249           */
   1250          void SampleApp_Uint16ToStr(uint16 guid, uint8* guid_str)
   1251          {
   1252              uint8 ch;
   1253              ch = guid / 256 / 16;
   1254              ch = ch > 9 ? ch + 'A' - 10 : ch + '0';
   1255              guid_str[0] = ch;
   1256              ch = guid / 256 % 16;
   1257              ch = ch > 9 ? ch + 'A' - 10 : ch + '0';
   1258              guid_str[1] = ch;
   1259              ch = guid % 256 / 16;
   1260              ch = ch > 9 ? ch + 'A' - 10 : ch + '0';
   1261              guid_str[2] = ch;
   1262              ch = guid % 256 % 16;
   1263              ch = ch > 9 ? ch + 'A' - 10 : ch + '0';
   1264              guid_str[3] = ch;
   1265          }
   1266          /*********************************************************************
   1267           * @fn      SampleApp_GetShortAddrStr
   1268           *
   1269           * @brief   point to point.
   1270           *
   1271           * @param   addrCA
   1272           *
   1273           * @return  none
   1274           */
   1275          #if ( ZSTACK_DEVICE_BUILD == DEVICE_BUILD_ENDDEVICE )	//终端设备
   1276          void SampleApp_GetGUIDStr(uint8* str)
   1277          {
   1278              uint8 ch;
   1279              uint16 _guid = GUID;
   1280              ch = _guid / 256 / 16;
   1281              ch = ch > 9 ? ch + 'A' - 10 : ch + '0';
   1282              str[0] = ch;
   1283              ch = _guid / 256 % 16;
   1284              ch = ch > 9 ? ch + 'A' - 10 : ch + '0';
   1285              str[1] = ch;
   1286              ch = _guid % 256 / 16;
   1287              ch = ch > 9 ? ch + 'A' - 10 : ch + '0';
   1288              str[2] = ch;
   1289              ch = _guid % 256 % 16;
   1290              ch = ch > 9 ? ch + 'A' - 10 : ch + '0';
   1291              str[3] = ch;
   1292          }
   1293          #endif //终端设备
   1294          
   1295          /*********************************************************************
   1296           * @fn      SampleApp_GetShortAddrStr
   1297           *
   1298           * @brief   point to point.
   1299           *
   1300           * @param   addrCA
   1301           *
   1302           * @return  none
   1303           */
   1304          void SampleApp_GetShortAddrStr(uint8* addrCA)
   1305          {
   1306              uint8 ch;
   1307              uint16 _shortAddr;
   1308              _shortAddr = NLME_GetShortAddr();
   1309              ch = _shortAddr / 256 / 16;
   1310              ch = ch > 9 ? ch + 'A' - 10 : ch + '0';
   1311              addrCA[0] = ch;
   1312              ch = _shortAddr / 256 % 16;
   1313              ch = ch > 9 ? ch + 'A' - 10 : ch + '0';
   1314              addrCA[1] = ch;
   1315              ch = _shortAddr % 256 / 16;
   1316              ch = ch > 9 ? ch + 'A' - 10 : ch + '0';
   1317              addrCA[2] = ch;
   1318              ch = _shortAddr % 256 % 16;
   1319              ch = ch > 9 ? ch + 'A' - 10 : ch + '0';
   1320              addrCA[3] = ch;
   1321          }
   1322          /*********************************************************************
   1323           * @fn      SampleApp_GetShortAddrStr
   1324           *
   1325           * @brief   从4字节字符串中获取16bit的短地址
   1326           *
   1327           * @param   addrCA
   1328           *
   1329           * @return  none
   1330           */
   1331          uint8 _SampleApp_CharToHex(uint8 ch)
   1332          {
   1333              if( ch >= '0' && ch <= '9' )
   1334              {
   1335                  return ch - '0';
   1336              }
   1337              else if( ch >= 'A' && ch <= 'F' )
   1338              {
   1339                  return ch - 'A' + 10;
   1340              }
   1341              else
   1342              {
   1343                  return 0;
   1344              }
   1345          }
   1346          uint16 SampleApp_GetShortAddrUint16(uint8* addrCA)
   1347          {
   1348              uint16 _shortAddr = 0;
   1349              uint8 i = 0;
   1350              for( i=0;i<4;i++ )
   1351              {
   1352                  _shortAddr *= 16;
   1353                  _shortAddr += _SampleApp_CharToHex(addrCA[i]);
   1354              }
   1355              return _shortAddr;
   1356          }
   1357          /*********************************************************************
   1358          *********************************************************************/

Errors: 1
Warnings: 5
